<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- ✅ズーム不要：ダブルタップズーム等を抑止 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1" />

  <!-- PWA設定 -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="三連電卓" />

  <link rel="manifest" href="manifest.json?v=2" />
  <link rel="apple-touch-icon" sizes="180x180" href="icon.png?v=2" />

  <title>三連電卓</title>

  <style>
  :root{
    /* ===== ノジマ風カラー ===== */
    --wood1:#0d3f91;
    --wood2:#082b66;

    --glass:rgba(255,255,255,.12);
    --panel:rgba(255,255,255,.95);
    --bd:rgba(0,0,0,.18);
    --neg:#d92d20;

    /* ===== 8行表示のターゲット ===== */
    --rowsVisible: 8;
    --rowH: 52px;        /* JSで自動調整 */
    --rowHMin: 44px;     /* 潰れ防止：これ以上は詰めない */
    --rowHMax: 52px;

    /* ✅詰めた時に一緒に変える（JSが上書き） */
    --rowPadV: 8px;
    --rowPadH: 10px;
    --rowGap: 4px;

    /* ✅ラベル：読みやすさ優先（JSが上書き） */
    --labelFS: 15px;

    /* 数字表示 */
    --numMax: 30px;
    --numMin: 12px;

    /* 合計 */
    --topMax: 46px;
    --topMin: 18px;

    /* ===== ここが “全iPadで勝手に最適” の核 ===== */
    --calcW: clamp(300px, 28vw, 380px);
    --colMinW: 240px;
    --safeB: env(safe-area-inset-bottom, 0px);

    /* ===== キー ===== */
    --gap: 10px;
    --keyFS: 38px;
    --keyFSop: 40px;
    --keyFSfunc: 36px;
    --keyRadius: 14px;

    /* ✅キー高さ：縦方向に “なるべく目一杯” 使う（でも上限あり） */
    --keyH: clamp(64px, 8.6vh, 92px);

    /* ===== ボタン配色 ===== */
    --btnGrey1: rgba(255,255,255,.98);
    --btnGrey2: rgba(230,235,245,.95);

    --btnOp1: rgba(60,120,230,.95);
    --btnOp2: rgba(30,80,180,.95);

    --btnFunc1: rgba(10,45,120,.85);
    --btnFunc2: rgba(5,25,70,.90);

    --btnUndo1: rgba(255,150,40,.95);
    --btnUndo2: rgba(220,110,20,.95);

    --btnRedo1: rgba(255,180,70,.95);
    --btnRedo2: rgba(230,120,30,.95);

    --tabBlue:#ffffff;

    /* スワイプ削除 */
    --delW: 86px;
    --delBg: #e11d48;
  }

  /* ✅縦：1列表示＋列切替（“ACまで1枚”を優先） */
  @media (orientation:portrait){
    :root{
      --calcW: 340px;
      --colMinW: 340px;
      --gap: 9px;
      --keyFS: 40px;
      --keyFSop: 42px;
      --keyFSfunc: 38px;
      --keyH: clamp(62px, 7.8vh, 90px);
    }
  }

  /* ✅高さが厳しい端末だけ（mini等）キーを少しだけ縮める */
  @media (max-height: 720px){
    :root{ --keyH: clamp(56px, 7.2vh, 86px); }
  }

  *{ box-sizing:border-box; }
  html, body{
    margin:0;
    padding:0;
    height:100%;
    overflow:hidden;
    overscroll-behavior: none;
    -webkit-text-size-adjust: 100%;
    background:linear-gradient(180deg,var(--wood1),var(--wood2));
  }

  /* ✅Safari/PWAの “下の余白” を物理的に潰す（固定レイアウト） */
  .frame{
    position:fixed;
    inset:0;
    padding:10px;
    padding-bottom: calc(10px + var(--safeB));
    max-width:1360px;
    margin:0 auto;
    overflow:hidden;
  }

  .app{
    height:100%;
    min-height:0;
    background:linear-gradient(180deg,var(--wood1),var(--wood2));
    border-radius:20px;
    padding:12px;
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:hidden;
  }

  /* ✅上が2段になって縦を食わないようにする（8行に効く） */
  .topbar{
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap:nowrap;
    overflow-x:auto;
    -webkit-overflow-scrolling: touch;
  }
  .topbar::-webkit-scrollbar{ display:none; }

  .tabs{display:flex;gap:8px;align-items:center;flex:0 0 auto}
  .tab{
    min-width:92px;
    padding:8px 10px;
    border-radius:12px;
    background:rgba(255,255,255,.88);
    border:1px solid rgba(0,0,0,.20);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.45);
    font-weight:900;
    color:#0b3a8a;
    text-align:center;
    cursor:pointer;
    user-select:none;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .tab.active{
    background:linear-gradient(180deg, #2e6cff, #0b3a8a);
    color:#fff;
  }
  .topRight{
    margin-left:auto;
    display:flex;
    gap:10px;
    align-items:center;
    flex:0 0 auto;
  }

  .gear{
    width:52px;height:42px;border-radius:12px;
    display:grid;place-items:center;cursor:pointer;user-select:none;
    background:rgba(255,255,255,.80);
    border:1px solid rgba(0,0,0,.22);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.45), 0 3px 10px rgba(0,0,0,.10);
    font-size:20px;font-weight:900;
  }

  .linkBar{display:flex;gap:8px;align-items:center}
  .linkBtn{
    width:64px;height:42px;border-radius:10px;
    display:grid;place-items:center;
    background:linear-gradient(180deg, rgba(255,255,255,.92), rgba(230,230,230,.92));
    border:1px solid rgba(0,0,0,.22);
    box-shadow:inset 0 2px 0 rgba(255,255,255,.65), 0 2px 6px rgba(0,0,0,.10);
    font-weight:1000;color:#5b2b86;cursor:pointer;user-select:none;
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding:0 6px;
  }
  .linkBtn.disabled{color:#667085}

  .grid{
    flex:1; min-height:0;
    display:grid;
    grid-template-columns: 1fr var(--calcW);
    gap:12px;
    overflow:hidden;
  }

  .leftWrap{
    min-height:0;
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:hidden;
    flex:1;
  }

  .lists{
    flex:1; min-height:0;
    display:grid;
    grid-template-columns:repeat(3, minmax(var(--colMinW), 1fr));
    gap:10px;
    overflow:hidden;
  }
  @media (orientation:portrait){
    .lists{grid-template-columns:repeat(1, minmax(var(--colMinW), 1fr));}
  }

  /* ✅ACは必ず表示＆押し出されない */
  .acRow{
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:10px;
    flex:0 0 auto;
    flex-shrink:0;
  }
  @media (orientation:portrait){
    .acRow{ grid-template-columns:repeat(1,1fr); }
  }

  .col{
    min-width:var(--colMinW);
    background:var(--glass);
    border:1px solid var(--bd);
    border-radius:16px;
    padding:8px;
    display:flex;
    flex-direction:column;
    gap:8px;
    min-height:0;
    overflow:hidden;
  }

  /* ✅合計 */
  .topBox{
    background:rgba(255,255,255,.72);
    border:1px solid rgba(0,0,0,.26);
    border-radius:14px;
    padding:8px 10px;
    display:flex;align-items:center;justify-content:flex-end;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.45);
    font-weight:1100;
    font-variant-numeric: tabular-nums;
    white-space:nowrap; overflow:hidden;
    color:#111;
  }
  .topBox.neg{color:var(--neg)}
  .topSpan{display:inline-block;max-width:100%}

  .panel{
    flex:1; min-height:0;
    background:var(--panel);
    border:1px solid rgba(0,0,0,.12);
    border-radius:14px;
    overflow:auto;
    -webkit-overflow-scrolling: touch;
  }

  .row{
    border-bottom:1px solid #eaeaea;
    min-height:var(--rowH);
    position:relative;
    overflow:hidden;
    cursor:pointer;
    user-select:none;
    touch-action: pan-y;
    background:transparent;
  }
  .row:last-child{border-bottom:none}

  .row.active{
    outline:3px solid rgba(0,0,0,.10);
    outline-offset:-3px;
  }
  .row.active .rowMain{
    background:rgba(0,0,0,.05);
  }

  .rowMain{
    width:100%;
    padding: var(--rowPadV) var(--rowPadH);
    min-height:var(--rowH);
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    gap: var(--rowGap);
    background:var(--panel);
    position:relative;
    z-index:2;
    transition:transform .14s ease;
    will-change:transform;
  }

  .row:nth-child(even) .rowMain{ background:rgba(0,0,0,.010); }
  .row.active:nth-child(even) .rowMain{ background:rgba(0,0,0,.05); }

  .row.swiped .rowMain{ transform: translateX(calc(-1 * var(--delW))); }

  .delBtn{
    position:absolute;
    right:0; top:0; bottom:0;
    width:var(--delW);
    border:none;
    background:var(--delBg);
    color:#fff;
    font-weight:1000;
    font-size:14px;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    opacity:0;
    pointer-events:none;
    z-index:1;
  }
  .row.swiped .delBtn{ opacity:1; pointer-events:auto; }

  .labelLine{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    min-height:18px;
  }
  .label{
    font-size:var(--labelFS);
    font-weight:1000;
    color:#0b1220;
    letter-spacing:.2px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    flex:1;
    cursor:pointer; /* ✅ラベルタップで編集モーダル */
  }
  .label.empty{color:transparent}

  .numLine{
    display:flex;
    align-items:flex-end;
    justify-content:flex-end;
    font-weight:1100;
    font-variant-numeric: tabular-nums;
    white-space:nowrap;
    overflow:hidden;
    color:#111;
    min-height:22px;
  }
  .numLine.neg{color:var(--neg)}
  .numSpan{display:inline-block;max-width:100%}

  .acBtn{
    height:50px;border-radius:14px;
    background:linear-gradient(180deg, rgba(255,255,255,.98), rgba(230,235,245,.95));
    border:1px solid rgba(0,0,0,.22);
    box-shadow:inset 0 2px 0 rgba(255,255,255,.65), 0 2px 6px rgba(0,0,0,.10);
    display:grid;place-items:center;
    font-weight:1100;font-size:32px;color:#1f3a8a;
    cursor:pointer;user-select:none;
    width:100%;
  }

  /* ===== 右：電卓 ===== */
  .calc{
    min-height:0;
    background:var(--glass);
    border:1px solid var(--bd);
    border-radius:16px;
    padding:12px;
    display:grid;
    grid-template-rows: auto 1fr 1fr;
    gap:10px;
    overflow:hidden;
  }

  .colTabs{
    display:none;
    gap:8px;
    align-items:center;
    justify-content:flex-end;
    flex-wrap:wrap;
  }
  @media (orientation:portrait){
    .colTabs{display:flex;}
  }
  .colTab{
    min-width:92px;
    padding:8px 10px;
    border-radius:10px;
    background:linear-gradient(180deg, rgba(255,255,255,.85), rgba(235,235,235,.85));
    border:1px solid rgba(0,0,0,.25);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.6), 0 2px 7px rgba(0,0,0,.10);
    font-weight:1000;
    color:#0b3a8a;
    text-align:center;
    cursor:pointer;
    user-select:none;
  }
  .colTab.active{
    background:linear-gradient(180deg, rgba(90,140,230,.85), rgba(60,110,210,.85));
    color:#fff;
  }

  .padNum{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:var(--gap);
    align-content:stretch;
    grid-auto-rows: 1fr;
    min-height:0;
  }
  .padOps{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:var(--gap);
    align-content:stretch;
    grid-auto-rows: 1fr;
    min-height:0;
  }

  .key{
    height:100%;
    min-height:var(--keyH);
    border-radius:var(--keyRadius);
    background:linear-gradient(180deg, rgba(255,255,255,.98), rgba(230,235,245,.95));
    border:1px solid rgba(0,0,0,.22);
    box-shadow:inset 0 2px 0 rgba(255,255,255,.65), 0 2px 6px rgba(0,0,0,.10);
    display:grid;place-items:center;
    font-weight:1200;
    cursor:pointer;user-select:none;
    overflow:hidden;
  }
  .key .kspan{display:inline-block;max-width:100%;padding:0 6px;white-space:nowrap}

  .numKey{ font-size:var(--keyFS); color:#111; }

  .opKey{
    background:linear-gradient(180deg, rgba(60,120,230,.95), rgba(30,80,180,.95));
    border-color:rgba(0,0,0,.22);
    font-size:var(--keyFSop);
    color:#fff;
    text-shadow: 0 1px 2px rgba(0,0,0,.35);
  }

  .funcKey{
    background:linear-gradient(180deg, rgba(10,45,120,.85), rgba(5,25,70,.90));
    border-color:rgba(0,0,0,.35);
    font-size:var(--keyFSfunc);
    color:#fff;
  }
  .undoKey{
    background:linear-gradient(180deg, rgba(255,150,40,.95), rgba(220,110,20,.95));
    border-color:rgba(0,0,0,.35);
    color:#fff;
    font-size:var(--keyFSfunc);
  }
  .redoKey{
    background:linear-gradient(180deg, rgba(255,180,70,.95), rgba(230,120,30,.95));
    border-color:rgba(0,0,0,.35);
    color:#fff;
    font-size:var(--keyFSfunc);
  }
  .eqKey{
    background:linear-gradient(180deg, #ff8c00, #e45b00);
    color:#fff;
    border:1px solid rgba(0,0,0,.35);
    box-shadow:inset 0 2px 0 rgba(255,255,255,.15), 0 3px 8px rgba(0,0,0,.25);
    font-size:var(--keyFSfunc);
  }

  .key:active,.acBtn:active,.linkBtn:active,.gear:active,.colTab:active{transform:translateY(1px)}

  /* ===== modal（設定） ===== */
  .backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.45);
    display:none;align-items:center;justify-content:center;
    z-index:999;padding:12px;
  }
  .modal{
    width:min(920px,100%);
    max-height:92vh;
    background:#fff;border-radius:18px;overflow:hidden;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    display:flex;flex-direction:column;

    /* ✅ここで「潰れ感」を改善 */
    font-size:16px;
    line-height:1.45;
  }
  .mHead{
    padding:14px 16px; /* ✅少し増やす */
    display:flex;justify-content:space-between;align-items:center;
    border-bottom:1px solid #eee;
    flex:0 0 auto
  }
  .mHead h2{margin:0;font-size:17px} /* ✅見出し少し大きく */
  .mBody{
    padding:16px; /* ✅少し増やす */
    display:grid;
    gap:16px;     /* ✅詰まりを減らす */
    overflow:auto;
    -webkit-overflow-scrolling: touch;
    flex:1 1 auto;
  }
  .sec{
    border:1px solid #eee;border-radius:14px;
    padding:14px; /* ✅少し増やす */
  }
  .secTitle{
    font-weight:1000;
    margin-bottom:10px;
    font-size:15px; /* ✅少し大きく */
  }
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px} /* ✅少し余白 */
  @media(max-width:760px){.grid2{grid-template-columns:1fr}}
  label.form{
    display:block;
    font-size:13px; /* ✅少し大きく */
    color:#475467;
    margin:10px 0 6px; /* ✅余白増やす */
  }

  /* ✅iOSフォーカスズーム対策：入力は16px以上 */
  input{
    width:100%;
    padding:12px 12px; /* ✅少し増やす */
    border:1px solid #d0d5dd;
    border-radius:12px;
    font-size:16px;
  }

  .mActions{
    padding:12px 14px;
    display:flex;gap:10px;justify-content:flex-end;
    border-top:1px solid #eee;flex-wrap:wrap;flex:0 0 auto
  }
  .btn{
    padding:10px 12px;
    border-radius:12px;
    border:1px solid #d0d5dd;
    background:#fff;
    cursor:pointer;
    font-weight:900;
    font-size:14px; /* ✅ボタン文字も安定 */
  }
  .btn.primary{background:#111;color:#fff;border-color:#111}
  .btn.danger{background:#b42318;color:#fff;border-color:#b42318}
  .small{font-size:12px;color:#667085;margin-top:6px}

  /* ===== ✅ラベル編集モーダル ===== */
  .editBackdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.55);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:1200;
    padding:12px;
  }
  .editModal{
    width:min(560px, 100%);
    background:#fff;
    border-radius:18px;
    overflow:hidden;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    display:flex;
    flex-direction:column;

    /* ✅こちらも読みやすさ確保 */
    font-size:16px;
    line-height:1.45;
  }
  .eHead{
    padding:14px 16px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    border-bottom:1px solid #eee;
  }
  .eHeadTitle{
    font-weight:1000;
    font-size:16px;
    margin:0;
  }
  .eBody{
    padding:16px;
    display:grid;
    gap:10px;
  }
  .eHint{
    font-size:12px;
    color:#667085;
    line-height:1.45;
  }
  .eInput{
    width:100%;
    padding:12px 12px;
    border:1px solid #d0d5dd;
    border-radius:14px;
    font-size:18px;
    font-weight:900;
    outline:none;
  }
  .eActions{
    padding:12px 14px;
    display:flex;
    gap:10px;
    justify-content:flex-end;
    flex-wrap:wrap;
    border-top:1px solid #eee;
  }

  /* ===== ✅iPad mini 横画面対策（ここだけ変更）===== */
  @media screen
    and (min-width: 768px)
    and (max-width: 1024px)
    and (orientation: landscape){

    :root{
      /* ✅右（電卓）をさらに小さく → 左が広がる */
      --calcW: 280px;

      /* ✅左の最小幅を少し上げて「入力列が潰れにくい」 */
      --colMinW: 210px;

      /* 少しだけ詰めてスペースを捻出 */
      --gap: 8px;
    }

    .grid{
      grid-template-columns: minmax(0,1fr) var(--calcW);
      gap:10px;
    }

    .lists{
      grid-template-columns: repeat(3, minmax(var(--colMinW), 1fr));
      gap:10px;
    }
  }
  </style>
</head>

<body>
<div class="frame">
  <div class="app">
    <div class="topbar">
      <div class="tabs" id="tabs"></div>

      <div class="topRight">
        <div class="gear" id="gear" title="設定">⚙️</div>
        <div class="linkBar" id="linkBar"></div>
      </div>
    </div>

    <div class="grid">
      <div class="leftWrap">
        <div class="lists" id="lists"></div>

        <!-- ✅ACは常に表示 -->
        <div class="acRow" id="acRow">
          <div class="acBtn" id="ac1">AC</div>
          <div class="acBtn" id="ac2">AC</div>
          <div class="acBtn" id="ac3">AC</div>
        </div>
      </div>

      <div class="calc">
        <div class="colTabs" id="colTabs"></div>

        <!-- 上：テンキー（配置変更しない） -->
        <div class="padNum" id="padNum">
          <div class="key numKey" data-k="7"><span class="kspan">7</span></div>
          <div class="key numKey" data-k="8"><span class="kspan">8</span></div>
          <div class="key numKey" data-k="9"><span class="kspan">9</span></div>

          <div class="key numKey" data-k="4"><span class="kspan">4</span></div>
          <div class="key numKey" data-k="5"><span class="kspan">5</span></div>
          <div class="key numKey" data-k="6"><span class="kspan">6</span></div>

          <div class="key numKey" data-k="1"><span class="kspan">1</span></div>
          <div class="key numKey" data-k="2"><span class="kspan">2</span></div>
          <div class="key numKey" data-k="3"><span class="kspan">3</span></div>

          <div class="key numKey" data-k="0"><span class="kspan">0</span></div>
          <div class="key numKey" data-k="00"><span class="kspan">00</span></div>
          <div class="key numKey" data-k="."><span class="kspan">.</span></div>
        </div>

        <!-- 下：演算（9個）（配置変更しない） -->
        <div class="padOps" id="padOps">
          <div class="key opKey" data-k="NEG"><span class="kspan">±</span></div>
          <div class="key opKey" data-k="MUL"><span class="kspan">×</span></div>
          <div class="key opKey" data-k="ADD"><span class="kspan">＋</span></div>

          <div class="key funcKey" data-k="C"><span class="kspan">C</span></div>
          <div class="key opKey" data-k="DIV"><span class="kspan">÷</span></div>
          <div class="key opKey" data-k="SUB"><span class="kspan">－</span></div>

          <div class="key undoKey" data-k="UNDO"><span class="kspan">↩︎</span></div>
          <div class="key redoKey" data-k="REDO"><span class="kspan">↪︎</span></div>
          <div class="key eqKey" data-k="ENTER"><span class="kspan">＝</span></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- modal（設定） -->
<div class="backdrop" id="backdrop">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="mHead">
      <h2>設定</h2>
      <button class="btn" type="button" id="closeM">閉じる</button>
    </div>

    <div class="mBody">
      <div class="sec">
        <div class="secTitle">リンク（横4つ）</div>
        <div class="grid2" id="linksForm"></div>
        <div class="small">URLが空なら未設定（ボタン押下でこの設定が開きます）。</div>
      </div>

      <div class="sec">
        <div class="secTitle">タブ名（固定5）</div>
        <div class="grid2" id="tabsForm"></div>
      </div>

      <div class="sec">
        <div class="secTitle">枠数（列ごと）</div>
        <div class="grid2" id="rowsForm"></div>
        <div class="small">列1/列2/列3 を別々に設定できます（最大40）。</div>
      </div>

      <div class="sec">
        <div class="secTitle">消去</div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn danger" type="button" id="wipeTab">このタブを全消去</button>
          <button class="btn danger" type="button" id="wipeAll">全タブを全消去</button>
        </div>
      </div>
    </div>

    <div class="mActions">
      <button class="btn" type="button" id="cancelM">キャンセル</button>
      <button class="btn primary" type="button" id="saveM">保存</button>
    </div>
  </div>
</div>

<!-- ✅ラベル編集モーダル -->
<div class="editBackdrop" id="editBackdrop">
  <div class="editModal" role="dialog" aria-modal="true">
    <div class="eHead">
      <div class="eHeadTitle" id="editTitle">項目名を編集</div>
      <button class="btn" type="button" id="editClose">閉じる</button>
    </div>
    <div class="eBody">
      <div class="eHint" id="editHint">ここに項目名を入力して「保存」。</div>
      <input class="eInput" id="editInput" type="text" placeholder="例：頭金" />
    </div>
    <div class="eActions">
      <button class="btn" type="button" id="editClear">空にする</button>
      <button class="btn" type="button" id="editCancel">キャンセル</button>
      <button class="btn primary" type="button" id="editSave">保存</button>
    </div>
  </div>
</div>

<script>
(() => {
  const KEY = "sanren_calc_2";
  const TAB_COUNT = 5;
  const COLS = 3;

  const DEFAULT_ROWS = [15,15,15];
  const MAX_ROWS = 40;

  // 入力上限：1千万
  const MAX_ABS = 10000000;

  const HISTORY_MAX = 400;
  const undoStack = [];
  const redoStack = [];
  let suppressHistory = false;

  const $ = (id)=>document.getElementById(id);
  const tabsEl = $("tabs");
  const listsEl = $("lists");
  const linkBar = $("linkBar");
  const gear = $("gear");
  const colTabsEl = $("colTabs");

  // 設定モーダル
  const backdrop = $("backdrop");
  const closeM = $("closeM");
  const cancelM = $("cancelM");
  const saveM = $("saveM");
  const linksForm = $("linksForm");
  const tabsForm = $("tabsForm");
  const rowsForm = $("rowsForm");

  const acRowEl = $("acRow");
  const ac1 = $("ac1");
  const ac2 = $("ac2");
  const ac3 = $("ac3");

  // ✅ラベル編集モーダル
  const editBackdrop = $("editBackdrop");
  const editClose = $("editClose");
  const editCancel = $("editCancel");
  const editSave = $("editSave");
  const editClear = $("editClear");
  const editInput = $("editInput");
  const editTitle = $("editTitle");
  const editHint  = $("editHint");
  let editingTarget = null; // {c,r}

  // ✅編集中フラグ：ラベル編集をモーダルに寄せるので「行選択の誤作動」防止に使用
  let isEditingLabel = false;

  // 入力状態
  let entry = "";
  let mode  = "num";   // "num" | "mul" | "div" | "sub"
  let sign  = +1;

  // state
  let state = load() || initial();
  let activeTab = clamp(state.activeTab, 0, TAB_COUNT-1);
  let activeCol = clamp(state.activeCol, 0, COLS-1);
  let activeRow = clamp(state.activeRow, 0, getRows(activeCol)-1);

  // render最適化
  let lastRenderKey = "";

  function initial(){
    return {
      activeTab:0, activeCol:0, activeRow:0,
      rowsByCol:[...DEFAULT_ROWS],
      tabs:Array.from({length:TAB_COUNT}, (_,i)=>({
        name:`List${i+1}`,
        cols:Array.from({length:COLS}, (__,c)=>({
          rows: Array.from({length:DEFAULT_ROWS[c]}, ()=>({label:"", kind:"num", value:null}))
        }))
      })),
      links:Array.from({length:4}, ()=>({label:"", url:""})),
      savedAt:new Date().toISOString()
    };
  }

  function save(){
    state.activeTab = activeTab;
    state.activeCol = activeCol;
    state.activeRow = activeRow;
    state.savedAt = new Date().toISOString();
    try{
      localStorage.setItem(KEY, JSON.stringify(state));
    }catch(e){
      console.warn("localStorage save failed:", e);
    }
  }

  function load(){
    try{
      const raw = localStorage.getItem(KEY);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      if(!obj.tabs || !obj.links || !obj.rowsByCol) return null;
      obj.tabs.forEach(t=>{
        t.cols.forEach((c, idx)=>{
          if(!c.rows){
            c.rows = Array.from(
              {length:(obj.rowsByCol?.[idx]||DEFAULT_ROWS[idx])},
              ()=>({label:"", kind:"num", value:null})
            );
          }
        });
      });
      return obj;
    }catch{ return null; }
  }

  function clamp(v,min,max){
    v = Number(v);
    if(!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, Math.trunc(v)));
  }

  function getRows(c){
    const n = Number(state.rowsByCol?.[c]);
    return Number.isFinite(n) && n>0 ? n : DEFAULT_ROWS[c];
  }

  function normalizeRows(col, targetRows){
    col.rows = Array.isArray(col.rows) ? col.rows.slice(0, targetRows) : [];
    while(col.rows.length < targetRows) col.rows.push({label:"", kind:"num", value:null});
  }

  function fmt(n){
    if(n===null || n===undefined) return "";
    if(!Number.isFinite(n)) return "Error";
    const [a,b]=String(n).split(".");
    const x = Number(a).toLocaleString("ja-JP");
    return b ? `${x}.${b}` : x;
  }

  // ✅入力中の文字列(entry)を「そのまま見せる」用（0. / 0.00 を崩さない）
  function fmtEntry(){
    if(entry === "") return "";

    // sign/mode による符号
    const prefix = (mode==="sub" || sign<0) ? "-" : "";

    // entry 自体は符号なし想定。整形は「小数点以下を保持」する。
    let s = String(entry);

    // 末尾 '.' も表示したいので split はそのまま
    const parts = s.split(".");
    let intPart = parts[0] ?? "";
    const decPart = parts.length > 1 ? (parts[1] ?? "") : null;

    // 整数部の先頭ゼロは「0」だけ残す
    intPart = intPart.replace(/^0+(?=\d)/, "");
    if(intPart === "") intPart = "0";

    // カンマ付け
    const intNum = Number(intPart);
    const intFmt = Number.isFinite(intNum) ? intNum.toLocaleString("ja-JP") : intPart;

    if(decPart === null){
      return prefix + intFmt;
    }
    // decPart は空でもOK（"0." を出すため）
    return prefix + intFmt + "." + decPart;
  }

  function withinLimit(n){
    return Number.isFinite(n) && Math.abs(n) <= MAX_ABS;
  }

  function calcResult(col){
    let total = 0;
    for(const r of col.rows){
      if(r.kind==="num" || r.kind==="sub" || r.kind==="add"){
        if(Number.isFinite(r.value)) total += r.value;
      }else if(r.kind==="mul"){
        if(Number.isFinite(r.value)) total *= r.value;
      }else if(r.kind==="div"){
        if(Number.isFinite(r.value) && r.value!==0) total /= r.value;
      }
    }
    return total;
  }

  function pushHistory(action){
    if(suppressHistory) return;
    undoStack.push(action);
    if(undoStack.length > HISTORY_MAX) undoStack.shift();
    redoStack.length = 0;
  }

  function applyAction(action, direction){
    const tab = state.tabs[action.tab];
    const col = tab.cols[action.col];
    normalizeRows(col, getRows(action.col));
    if(action.row >= col.rows.length) return;
    suppressHistory = true;
    try{
      col.rows[action.row] = { ...(direction==="undo" ? action.prev : action.next) };
      activeTab = action.tab;
      activeCol = action.col;
      activeRow = action.row;
      save();
      renderAll(true);
    } finally { suppressHistory = false; }
  }
  function undo(){ const a=undoStack.pop(); if(!a) return; applyAction(a,"undo"); redoStack.push(a); }
  function redo(){ const a=redoStack.pop(); if(!a) return; applyAction(a,"redo"); undoStack.push(a); }

  // ===== AutoFit =====
  function fitSpan(span, box, maxPx, minPx){
    if(!span || !box) return;

    const text = span.textContent ?? "";
    const prevText = span.dataset.prevText || "";
    const prevW = Number(span.dataset.prevW || "0");
    const bw = box.clientWidth;

    if(text === prevText && prevW === bw) return;

    span.dataset.prevText = text;
    span.dataset.prevW = String(bw);

    const st = getComputedStyle(box);
    const padL = parseFloat(st.paddingLeft)||0;
    const padR = parseFloat(st.paddingRight)||0;
    const avail = Math.max(10, bw - padL - padR);
    const fontFamily = st.fontFamily;
    const fontWeight = st.fontWeight;

    const canvas = fitSpan._c || (fitSpan._c = document.createElement("canvas"));
    const ctx = canvas.getContext("2d");

    let lo=minPx, hi=maxPx, best=minPx;
    while(lo<=hi){
      const mid=(lo+hi)>>1;
      ctx.font = `${fontWeight} ${mid}px ${fontFamily}`;
      const w = ctx.measureText(text).width;
      if(w<=avail){ best=mid; lo=mid+1; } else hi=mid-1;
    }
    span.style.fontSize = best+"px";
  }

  function cssNum(varName, fallback){
    const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    const n = Number(String(v).replace("px",""));
    return Number.isFinite(n) ? n : fallback;
  }

  function applyAutoFitVisible(){
    document.querySelectorAll(".topBox").forEach(box=>{
      fitSpan(box.querySelector(".topSpan"), box, cssNum("--topMax",46), cssNum("--topMin",18));
    });
    document.querySelectorAll(".numLine").forEach(box=>{
      fitSpan(box.querySelector(".numSpan"), box, cssNum("--numMax",30), cssNum("--numMin",12));
    });
    document.querySelectorAll(".key").forEach(k=>{
      const span = k.querySelector(".kspan");
      if(!span) return;
      const isOp  = k.classList.contains("opKey");
      const isFunc= k.classList.contains("funcKey") || k.classList.contains("undoKey") || k.classList.contains("redoKey") || k.classList.contains("eqKey");
      const max = isOp ? cssNum("--keyFSop",40) : (isFunc ? cssNum("--keyFSfunc",36) : cssNum("--keyFS",38));
      fitSpan(span, k, max, 18);
    });
  }

  function isPortrait(){
    return window.matchMedia && window.matchMedia("(orientation:portrait)").matches;
  }

  // ✅8行を「見た目が潰れない範囲で」詰める（詰めたら padding/font も一緒に調整）
  function fitRowHeightToTarget(){
    const panel = listsEl.querySelector(".panel");
    if(!panel) return;

    const root = document.documentElement;
    const target = cssNum("--rowsVisible", 8);

    const panelH = panel.clientHeight;
    if(panelH <= 0) return;

    let rh = Math.floor(panelH / target);

    const min = cssNum("--rowHMin", 44);
    const max = cssNum("--rowHMax", 52);
    rh = Math.max(min, Math.min(max, rh));

    root.style.setProperty("--rowH", rh + "px");

    if(rh <= 46){
      root.style.setProperty("--rowPadV", "6px");
      root.style.setProperty("--rowPadH", "10px");
      root.style.setProperty("--rowGap", "3px");
      root.style.setProperty("--labelFS", "14px");
      root.style.setProperty("--numMax", "28px");
      root.style.setProperty("--numMin", "12px");
    }else{
      root.style.setProperty("--rowPadV", "8px");
      root.style.setProperty("--rowPadH", "10px");
      root.style.setProperty("--rowGap", "4px");
      root.style.setProperty("--labelFS", "15px");
      root.style.setProperty("--numMax", "30px");
      root.style.setProperty("--numMin", "12px");
    }
  }

  function renderTabs(){
    tabsEl.innerHTML="";
    state.tabs.forEach((t,i)=>{
      const d=document.createElement("div");
      d.className="tab"+(i===activeTab?" active":"");
      d.textContent = t.name || `List${i+1}`;
      d.onclick=()=>{
        activeTab=i; activeCol=0; activeRow=0;
        entry=""; mode="num"; sign=+1;
        save(); renderAll(true);
      };
      tabsEl.appendChild(d);
    });
  }

  function renderColTabs(){
    colTabsEl.innerHTML="";
    for(let c=0;c<COLS;c++){
      const b=document.createElement("div");
      b.className="colTab"+(c===activeCol ? " active" : "");
      b.textContent = `List${c+1}`;
      b.onclick=()=>{
        activeCol=c;
        activeRow = Math.min(activeRow, getRows(activeCol)-1);
        entry=""; mode="num"; sign=+1;
        save();
        renderAll(true);
      };
      colTabsEl.appendChild(b);
    }
  }

  function renderLinks(){
    linkBar.innerHTML="";
    state.links.forEach((lnk)=>{
      const b=document.createElement("div");
      const has=!!(lnk.url && String(lnk.url).trim());
      b.className="linkBtn"+(has?"":" disabled");
      b.textContent = (lnk.label||"").trim();
      b.title = has ? lnk.url : "未設定（設定で入力）";
      b.onclick=()=>{
        if(!has){ openModal(); return; }
        window.open(String(lnk.url).trim(), "_blank", "noopener,noreferrer");
      };
      linkBar.appendChild(b);
    });
  }

  // ✅ここが修正版（0. / 0.0 / 0.00 の表示更新を保証）
  function setRow(next){
    const tab = state.tabs[activeTab];
    const col = tab.cols[activeCol];
    normalizeRows(col, getRows(activeCol));
    const before = {...col.rows[activeRow]};
    const after  = {...before, ...next};

    // ✅数値として同じでも、entry表示を更新したいので再描画
    if(before.label===after.label && before.kind===after.kind && before.value===after.value){
      renderLists();
      return;
    }

    pushHistory({tab:activeTab, col:activeCol, row:activeRow, prev:before, next:after});
    col.rows[activeRow] = after;
    save();
    renderLists();
  }

  function blankRow(){ return {label:"", kind:"num", value:null}; }

  function insertRowAt(c, r){
    const tab = state.tabs[activeTab];
    const col = tab.cols[c];
    normalizeRows(col, getRows(c));

    for(let i=col.rows.length-1;i>r;i--){
      col.rows[i] = {...col.rows[i-1]};
    }
    col.rows[r] = blankRow();

    activeCol = c;
    activeRow = r;
    entry=""; mode="num"; sign=+1;
    save();
    renderAll(true);
  }

  function deleteRowAt(c, r){
    const tab = state.tabs[activeTab];
    const col = tab.cols[c];
    normalizeRows(col, getRows(c));

    for(let i=r;i<col.rows.length-1;i++){
      col.rows[i] = {...col.rows[i+1]};
    }
    col.rows[col.rows.length-1] = blankRow();

    activeCol = c;
    activeRow = Math.min(r, col.rows.length-1);
    entry=""; mode="num"; sign=+1;
    save();
    renderAll(true);
  }

  function closeAllSwipes(exceptEl=null){
    document.querySelectorAll(".row.swiped").forEach(el=>{
      if(el!==exceptEl) el.classList.remove("swiped");
    });
  }

  function attachSwipeAndLongPress(rowEl, c, r){
    let sx=0, sy=0;
    let tracking=false;
    let longTimer=null;
    let longFired=false;

    const cancelLong = ()=>{
      if(longTimer){ clearTimeout(longTimer); longTimer=null; }
    };

    rowEl.addEventListener("pointerdown",(e)=>{
      if(isEditingLabel) return;
      try{ rowEl.setPointerCapture?.(e.pointerId); }catch{}

      sx = e.clientX; sy = e.clientY;
      tracking = true;
      longFired=false;

      closeAllSwipes(rowEl);

      cancelLong();
      longTimer = setTimeout(()=>{
        longFired=true;
        if(rowEl.classList.contains("swiped")) return;
        insertRowAt(c, r);
      }, 600);
    });

    rowEl.addEventListener("pointermove",(e)=>{
      if(!tracking || longFired) return;

      const dx = e.clientX - sx;
      const dy = e.clientY - sy;

      if(Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 10){
        cancelLong();
        return;
      }
      if(Math.abs(dx) > 14) cancelLong();

      if(dx < -34){
        rowEl.classList.add("swiped");
      }else if(dx > 22){
        rowEl.classList.remove("swiped");
      }
    });

    const end = ()=>{
      tracking=false;
      cancelLong();
    };
    rowEl.addEventListener("pointerup", end);
    rowEl.addEventListener("pointercancel", end);
    rowEl.addEventListener("lostpointercapture", end);
  }

  // ===== ✅ラベル編集モーダル制御（副作用少なめ版） =====
  function openLabelModal(c, r){
    const tab = state.tabs[activeTab];
    const col = tab.cols[c];
    normalizeRows(col, getRows(c));

    // 選択も合わせる
    activeCol = c;
    activeRow = r;
    entry = "";
    mode  = "num";
    sign  = +1;
    save();
    renderLists();

    editingTarget = { c, r };
    isEditingLabel = true;

    const cur = (col.rows[r].label || "");
    editTitle.textContent = `項目名を編集（列${c+1} / ${r+1}行）`;
    editHint.textContent  = "入力して「保存」。";
    editInput.value = cur;

    editBackdrop.style.display = "flex";

    // iOS対策：表示直後は少し遅らせてフォーカス
    setTimeout(()=>{
      editInput.focus({preventScroll:true});
      try{
        const v = editInput.value;
        editInput.setSelectionRange(v.length, v.length);
      }catch{}
    }, 50);
  }

  function closeLabelModal(){
    entry = "";
    mode  = "num";
    sign  = +1;
    editBackdrop.style.display = "none";
    editingTarget = null;
    isEditingLabel = false;
    renderLists();
  }

  function commitLabel(){
    if(!editingTarget) return;
    const c = editingTarget.c;
    const r = editingTarget.r;

    const tab = state.tabs[activeTab];
    const col = tab.cols[c];
    normalizeRows(col, getRows(c));

    const before = {...col.rows[r]};
    const afterLabel = (editInput.value || "").trim();
    const after = {...before, label: afterLabel};

    if(before.label !== after.label){
      pushHistory({tab:activeTab, col:c, row:r, prev:before, next:after});
      col.rows[r] = after;
      save();
    }
    closeLabelModal();
  }

  editClose.onclick = closeLabelModal;
  editCancel.onclick = closeLabelModal;
  editClear.onclick = ()=>{ editInput.value=""; editInput.focus({preventScroll:true}); };
  editSave.onclick = commitLabel;

  editBackdrop.addEventListener("click",(e)=>{ if(e.target===editBackdrop) closeLabelModal(); });

  editInput.addEventListener("keydown",(e)=>{
    if(e.key==="Enter"){ e.preventDefault(); commitLabel(); }
    if(e.key==="Escape"){ e.preventDefault(); closeLabelModal(); }
  });

  function renderLists(){
    const renderKey = [
      activeTab, activeCol, activeRow,
      state.rowsByCol?.join(","),
      isPortrait() ? "P":"L",
      state.savedAt,

      // ✅ここが修正版（entry変化だけでも再描画される）
      entry,
      mode,
      sign
    ].join("|");

    if(renderKey === lastRenderKey){
      requestAnimationFrame(applyAutoFitVisible);
      return;
    }
    lastRenderKey = renderKey;

    listsEl.innerHTML="";
    const tab = state.tabs[activeTab];
    for(let c=0;c<COLS;c++) normalizeRows(tab.cols[c], getRows(c));

    const portrait = isPortrait();
    const colsToShow = portrait ? [activeCol] : [0,1,2];

    if(portrait){
      ac2.style.display="none";
      ac3.style.display="none";
      acRowEl.style.gridTemplateColumns = "1fr";
    }else{
      ac2.style.display="";
      ac3.style.display="";
      acRowEl.style.gridTemplateColumns = "repeat(3, 1fr)";
    }

    colsToShow.forEach((c)=>{
      const col = tab.cols[c];
      const colEl=document.createElement("div");
      colEl.className="col";

      const res=calcResult(col);
      const top=document.createElement("div");
      top.className="topBox"+(res<0?" neg":"");
      const topSpan=document.createElement("span");
      topSpan.className="topSpan";
      topSpan.textContent = fmt(res) || "0";
      top.appendChild(topSpan);

      const panel=document.createElement("div");
      panel.className="panel";

      for(let r=0;r<col.rows.length;r++){
        const it = col.rows[r];

        const row=document.createElement("div");
        row.className="row"+(c===activeCol && r===activeRow ? " active":"");

        const rowMain=document.createElement("div");
        rowMain.className="rowMain";

        rowMain.onclick=()=>{
          if(isEditingLabel) return;
          if(row.classList.contains("swiped")){
            row.classList.remove("swiped");
            return;
          }
          activeCol=c; activeRow=r;
          entry=""; mode="num"; sign=+1;
          save();
          renderLists();
        };

        const delBtn=document.createElement("button");
        delBtn.className="delBtn";
        delBtn.type="button";
        delBtn.textContent="削除";
        delBtn.onclick=(ev)=>{
          ev.stopPropagation();
          deleteRowAt(c, r);
          closeAllSwipes();
        };

        const labelLine=document.createElement("div");
        labelLine.className="labelLine";

        const lab=document.createElement("div");
        lab.className="label";
        const t=(it.label||"");
        if(!t.trim()){ lab.classList.add("empty"); lab.innerHTML="&nbsp;"; }
        else lab.textContent=t;

        // ✅「編集」表示は撤去。ラベルタップで編集モーダルを開くのみ
        const onOpen = (ev)=>{
          ev.stopPropagation();
          if(row.classList.contains("swiped")) row.classList.remove("swiped");
          openLabelModal(c, r);
        };
        lab.onclick = onOpen;

        labelLine.append(lab);

        const numLine=document.createElement("div");
        numLine.className="numLine";

        let show="";
        if(it.kind==="num"){
          // ✅入力中の 0. / 0.00 を崩さない
          if(c===activeCol && r===activeRow && entry!==""){
            show = fmtEntry();
          }else if(Number.isFinite(it.value)){
            show = fmt(it.value);
          }

          // 色：入力中は fmtEntry() の符号で判定
          if(c===activeCol && r===activeRow && entry!==""){
            if(fmtEntry().startsWith("-")) numLine.classList.add("neg");
          }else if(Number.isFinite(it.value) && it.value<0){
            numLine.classList.add("neg");
          }
        }else if(it.kind==="add"){
          show = Number.isFinite(it.value) ? fmt(it.value) : "＋";
        }else if(it.kind==="sub"){
          if(Number.isFinite(it.value)) { show = fmt(it.value); numLine.classList.add("neg"); }
          else show = "－";
        }else if(it.kind==="mul"){
          show = Number.isFinite(it.value) ? `×${fmt(it.value)}` : "×";
        }else if(it.kind==="div"){
          show = Number.isFinite(it.value) ? `÷${fmt(it.value)}` : "÷";
        }

        const numSpan=document.createElement("span");
        numSpan.className="numSpan";
        numSpan.textContent=show;
        numLine.appendChild(numSpan);

        rowMain.append(labelLine,numLine);
        row.append(rowMain, delBtn);
        panel.appendChild(row);

        attachSwipeAndLongPress(row, c, r);
      }

      colEl.append(top,panel);
      listsEl.appendChild(colEl);
    });

    listsEl.onclick = (e)=>{
      const row = e.target.closest(".row");
      if(!row) closeAllSwipes();
    };

    // AC：確認なし（常に押せる）
    ac1.onclick=()=> clearCol( portrait ? activeCol : 0 );
    ac2.onclick=()=> clearCol(1);
    ac3.onclick=()=> clearCol(2);

    requestAnimationFrame(()=>{
      fitRowHeightToTarget();
      applyAutoFitVisible();
    });
  }

  function clearCol(idx){
    const tab = state.tabs[activeTab];
    const col = tab.cols[idx];
    normalizeRows(col, getRows(idx));
    for(let r=0;r<col.rows.length;r++){
      const before={...col.rows[r]};
      const after ={label:"", kind:"num", value:null};
      pushHistory({tab:activeTab, col:idx, row:r, prev:before, next:after});
      col.rows[r]=after;
    }
    entry=""; mode="num"; sign=+1;

    if(activeCol === idx){
      activeRow = clamp(activeRow, 0, getRows(activeCol)-1);
    }

    save(); renderAll(true);
  }

  function appendDigit(d){
    const before = entry;

    if(d==="00"){
      if(entry==="" || entry==="0") return;
      entry += "00";
    }else if(d==="."){
      if(entry==="") entry="0.";
      else if(entry.includes(".")) return;
      else entry += ".";
    }else{
      if(entry==="0") entry="";
      entry += d;
    }

    const n = Number(entry);
    // "0." は Number("0.") で 0 になるけど、表示は entry が担当するのでOK。
    if(!Number.isFinite(n) || !withinLimit(n)){
      entry = before;
      return;
    }

    if(mode==="num"){
      setRow({kind:"num", value: sign*n});
    }else if(mode==="mul"){
      setRow({kind:"mul", value: n});
    }else if(mode==="div"){
      setRow({kind:"div", value: n});
    }else if(mode==="sub"){
      setRow({kind:"sub", value: -n});
    }
  }

  function clearAll(){
    entry=""; mode="num"; sign=+1;
    setRow({kind:"num", value:null});
  }

  function toggleNeg(){
    if(mode!=="num") { mode="num"; entry=""; sign=+1; }
    sign*=-1;
    const tab = state.tabs[activeTab];
    const cur = tab.cols[activeCol].rows[activeRow];
    if(Number.isFinite(cur.value)){
      const nv = -cur.value;
      if(withinLimit(nv)) setRow({kind:"num", value:nv});
    }else{
      // ✅未確定でも符号が変わったら画面更新（entry表示が変わる）
      renderLists();
    }
  }

  function pressAdd(){
    jumpNextRowIfHasNumber();   // ✅追加：数字があるなら次の行へ
    entry=""; mode="num"; sign=+1;
    setRow({kind:"add", value:null});
  }
  function pressSub(){
    jumpNextRowIfHasNumber();   // ✅追加
    entry=""; mode="sub"; sign=-1;
    setRow({kind:"sub", value:null});
  }
  function pressMul(){
    jumpNextRowIfHasNumber();   // ✅追加
    entry=""; mode="mul"; sign=+1;
    setRow({kind:"mul", value:null});
  }
  function pressDiv(){
    jumpNextRowIfHasNumber();   // ✅追加
    entry=""; mode="div"; sign=+1;
    setRow({kind:"div", value:null});
  }

  function enter(){
    entry=""; mode="num"; sign=+1;
    activeRow = Math.min(getRows(activeCol)-1, activeRow+1);
    save();
    renderLists();
  }
  function moveNextRow(){
  entry=""; mode="num"; sign=+1; // ✅追加：状態をリセット
  activeRow = Math.min(getRows(activeCol)-1, activeRow+1);
  save();
  renderLists();
}
  function jumpNextRowIfHasNumber(){
  const tab = state.tabs[activeTab];
  const cur = tab.cols[activeCol].rows[activeRow];

  if(entry !== "" || (cur.kind==="num" && Number.isFinite(cur.value))){
    moveNextRow();
    return true;
  }
    return false;
  }
  function handleKey(k){
    if(k==="UNDO") return undo();
    if(k==="REDO") return redo();
    if(/^[0-9]$/.test(k) || k==="00" || k===".") return appendDigit(k);
    if(k==="C") return clearAll();
    if(k==="NEG") return toggleNeg();
    if(k==="ADD") return pressAdd();
    if(k==="SUB") return pressSub();
    if(k==="MUL") return pressMul();
    if(k==="DIV") return pressDiv();
    if(k==="ENTER") return enter();
  }

  document.addEventListener("click",(e)=>{
    const btn=e.target.closest("[data-k]");
    if(!btn) return;
    handleKey(btn.getAttribute("data-k"));
  });

  function openModal(){ buildModal(); backdrop.style.display="flex"; }
  function closeModal(){ backdrop.style.display="none"; }

  gear.onclick=openModal;
  closeM.onclick=closeModal;
  cancelM.onclick=closeModal;
  backdrop.addEventListener("click",(e)=>{ if(e.target===backdrop) closeModal(); });

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }

  function buildModal(){
    linksForm.innerHTML="";
    state.links.forEach((lnk,i)=>{
      const box=document.createElement("div");
      box.innerHTML = `
        <div style="border:1px solid #eee;border-radius:14px;padding:12px">
          <div style="font-weight:1000;margin-bottom:8px">リンク${i+1}</div>
          <label class="form">ボタン名（空でもOK）</label>
          <input id="lnk_label_${i}" value="${escapeHtml(lnk.label||"")}">
          <label class="form">URL</label>
          <input id="lnk_url_${i}" value="${escapeHtml(lnk.url||"")}" placeholder="https://...">
        </div>`;
      linksForm.appendChild(box);
    });

    tabsForm.innerHTML="";
    state.tabs.forEach((t,i)=>{
      const box=document.createElement("div");
      box.innerHTML = `
        <div style="border:1px solid #eee;border-radius:14px;padding:12px">
          <div style="font-weight:1000;margin-bottom:8px">タブ${i+1}</div>
          <label class="form">タブ名</label>
          <input id="tab_name_${i}" value="${escapeHtml(t.name||`List${i+1}`)}">
        </div>`;
      tabsForm.appendChild(box);
    });

    rowsForm.innerHTML="";
    for(let c=0;c<COLS;c++){
      const cur=getRows(c);
      const box=document.createElement("div");
      box.innerHTML = `
        <div style="border:1px solid #eee;border-radius:14px;padding:12px">
          <div style="font-weight:1000;margin-bottom:8px">列${c+1}</div>
          <label class="form">枠数（1〜${MAX_ROWS}）</label>
          <input id="rows_${c}" type="number" min="1" max="${MAX_ROWS}" value="${cur}">
        </div>`;
      rowsForm.appendChild(box);
    }

    $("wipeTab").onclick=()=>{
      const t=state.tabs[activeTab];
      t.cols.forEach((c, ci)=>{
        normalizeRows(c, getRows(ci));
        c.rows = c.rows.map(()=>({label:"", kind:"num", value:null}));
      });
      entry=""; mode="num"; sign=+1;
      save(); renderAll(true);
    };

    $("wipeAll").onclick=()=>{
      state.tabs.forEach(t=>{
        t.cols.forEach((c, ci)=>{
          normalizeRows(c, getRows(ci));
          c.rows = c.rows.map(()=>({label:"", kind:"num", value:null}));
        });
      });
      entry=""; mode="num"; sign=+1;
      save(); renderAll(true);
    };
  }

  saveM.onclick=()=>{
    for(let i=0;i<4;i++){
      const label = document.getElementById(`lnk_label_${i}`).value;
      const url = document.getElementById(`lnk_url_${i}`).value.trim();
      state.links[i] = { label, url };
    }
    for(let i=0;i<TAB_COUNT;i++){
      const nm = document.getElementById(`tab_name_${i}`).value.trim() || `List${i+1}`;
      state.tabs[i].name = nm;
    }

    const newRows=[];
    for(let c=0;c<COLS;c++){
      const v = Number(document.getElementById(`rows_${c}`).value);
      const n = Number.isFinite(v) ? Math.max(1, Math.min(MAX_ROWS, Math.trunc(v))) : DEFAULT_ROWS[c];
      newRows.push(n);
    }
    state.rowsByCol=newRows;

    state.tabs.forEach(t=>{
      for(let c=0;c<COLS;c++) normalizeRows(t.cols[c], getRows(c));
    });

    activeRow = clamp(activeRow, 0, getRows(activeCol)-1);

    save();
    renderAll(true);
    closeModal();
  };

  function renderAll(force=false){
    if(force){
      lastRenderKey = "";
      document.querySelectorAll("[data-prev-text]").forEach(el=>{
        delete el.dataset.prevText;
        delete el.dataset.prevW;
      });
    }
    renderTabs();
    renderColTabs();
    renderLinks();
    renderLists();
  }

  let resizeTimer = null;
  window.addEventListener("resize", ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=>{
      renderColTabs();
      renderAll(true);
    }, 120);
  });

  document.addEventListener("pointerdown",(e)=>{
    if(e.target.closest(".row")) return;
    closeAllSwipes();
  }, {passive:true});

    // ✅ Service Worker 登録（起動高速化）
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(console.warn);
    });
  }

  save();
  renderAll(true);
})();
</script>
</body>
</html>
